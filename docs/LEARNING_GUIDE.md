# NPU学习指南

本文档帮助你理解NPU微架构的设计原理和学习要点。

## 学习路线图

### 第一阶段：基础概念（1-2天）

#### 1. 数字电路基础
- **组合逻辑 vs 时序逻辑**
  - 组合逻辑：输出仅依赖当前输入（如加法器、多路选择器）
  - 时序逻辑：输出依赖时钟和状态（如寄存器、状态机）
  
- **寄存器和触发器**
  - D触发器：在时钟边沿采样数据
  - 复位：异步复位 vs 同步复位
  
- **时序约束**
  - 建立时间（Setup Time）
  - 保持时间（Hold Time）
  - 时钟周期 = 组合逻辑延迟 + 建立时间

**实践**：阅读 `processing_element.v`，理解寄存器的使用

#### 2. 定点数运算
- **Q格式表示**
  - Q8.8：8位整数 + 8位小数
  - 范围：-128.0 到 +127.996
  - 精度：1/256 ≈ 0.0039
  
- **定点乘法**
  - Q8.8 × Q8.8 = Q16.16
  - 需要右移8位恢复到Q8.8格式
  
- **溢出处理**
  - 饱和运算
  - 截断 vs 舍入

**实践**：手算几个Q8.8格式的乘法，验证理解

### 第二阶段：核心模块（3-5天）

#### 1. 处理单元（PE）
**文件**：`processing_element.v`

**关键概念**：
- MAC（Multiply-Accumulate）运算
- 累加器设计
- 数据流传递

**学习要点**：
```verilog
// MAC运算的核心
accumulator <= accumulator + (data_in * weight_in);
```

**思考题**：
1. 为什么累加器需要32位宽度？
2. clear_acc信号的作用是什么？
3. 如何防止累加器溢出？

#### 2. 矩阵乘法单元
**文件**：`matrix_multiply_unit.v`

**关键概念**：
- 脉动阵列（Systolic Array）
- PE阵列互连
- 数据流调度

**脉动阵列原理**：
```
输入数据从左向右流动
权重固定在每个PE中
每个PE执行一次MAC运算
结果在最右侧输出
```

**学习要点**：
- 理解8×8 PE阵列的连接方式
- 数据如何在阵列中流动
- 为什么叫"脉动"阵列

**实践**：
- 画出3×3的脉动阵列数据流图
- 手动模拟一次矩阵乘法过程

#### 3. 激活函数单元
**文件**：`activation_unit.v`

**关键概念**：
- 非线性激活函数
- 查找表（LUT）优化
- 分段线性近似

**激活函数对比**：
| 函数 | 公式 | 范围 | 用途 |
|------|------|------|------|
| ReLU | max(0,x) | [0,∞) | 最常用 |
| Sigmoid | 1/(1+e^-x) | [0,1] | 二分类 |
| Tanh | (e^x-e^-x)/(e^x+e^-x) | [-1,1] | 归一化 |

**思考题**：
1. 为什么ReLU比Sigmoid更常用？
2. 如何用查找表实现Sigmoid？
3. 如何提高查找表的精度？

### 第三阶段：系统集成（3-5天）

#### 1. 控制单元
**文件**：`control_unit.v`

**关键概念**：
- 有限状态机（FSM）
- 状态转换
- 控制信号生成

**状态机设计模式**：
```verilog
// 三段式状态机
// 1. 当前状态寄存器
always @(posedge clk) state <= next_state;

// 2. 下一状态逻辑
always @(*) begin
    case (state)
        IDLE: if (start) next_state = COMPUTE;
        ...
    endcase
end

// 3. 输出逻辑
always @(posedge clk) begin
    case (state)
        IDLE: busy <= 0;
        COMPUTE: busy <= 1;
        ...
    endcase
end
```

**学习要点**：
- 理解每个状态的功能
- 状态转换条件
- 超时保护机制

**实践**：
- 画出完整的状态转换图
- 添加新状态（如DMA传输）

#### 2. AXI接口
**文件**：`axi_interface.v`

**关键概念**：
- AXI4-Lite协议
- 握手机制（valid/ready）
- 地址译码

**AXI握手规则**：
```
传输发生条件：valid && ready
主机控制valid
从机控制ready
valid不能等待ready（防止死锁）
```

**学习要点**：
- 5个独立通道的作用
- 写事务流程
- 读事务流程
- 寄存器映射

**实践**：
- 画出AXI写事务时序图
- 实现一个简单的AXI主机

### 第四阶段：验证和调试（2-3天）

#### 1. 测试平台
**文件**：`testbench/npu_tb.v`

**关键概念**：
- 测试激励生成
- 结果检查
- 波形分析

**测试方法**：
```verilog
// 1. 准备测试数据
test_input[0] = 16'h0100;  // 1.0

// 2. 执行AXI写操作
axi_write(addr, data);

// 3. 等待完成
wait(done);

// 4. 读取结果
axi_read(addr, result);

// 5. 检查结果
if (result != expected) $error("Mismatch!");
```

**学习要点**：
- 如何编写测试用例
- 如何生成时钟和复位
- 如何使用任务（task）
- 波形调试技巧

**实践**：
- 运行仿真，观察波形
- 添加新的测试用例
- 修复发现的bug

## 深入学习主题

### 1. 神经网络基础
**推荐资源**：
- 3Blue1Brown的神经网络视频系列
- 《深度学习》（花书）第6章

**核心概念**：
- 全连接层：Y = W×X + b
- 激活函数的作用
- 前向传播 vs 反向传播

### 2. 硬件加速原理
**为什么需要NPU？**
- CPU：通用计算，串行执行
- GPU：并行计算，适合矩阵运算
- NPU：专用加速，极致优化

**NPU优势**：
- 专用MAC单元（DSP）
- 片上缓存减少内存访问
- 流水线和并行处理
- 低功耗设计

### 3. 脉动阵列深入
**Google TPU架构**：
- 256×256 PE阵列
- 每周期65536次MAC运算
- 峰值性能：92 TOPS（INT8）

**设计权衡**：
- 阵列大小 vs 面积
- 数据位宽 vs 精度
- 缓存大小 vs 带宽

### 4. 优化技术

#### 数据重用
```
权重固定：减少内存访问
输入广播：多个PE共享
输出累加：片上完成
```

#### 流水线
```
阶段1：数据加载
阶段2：矩阵乘法
阶段3：激活函数
阶段4：数据写回
```

#### 量化
```
FP32 -> INT8：减少存储和计算
量化感知训练：保持精度
混合精度：权衡性能和精度
```

## 实践项目

### 初级项目
1. **修改矩阵大小**：改为4×4或16×16
2. **添加新激活函数**：Leaky ReLU, ELU
3. **性能计数器**：统计MAC操作次数

### 中级项目
1. **卷积加速**：添加卷积专用硬件
2. **池化单元**：Max Pooling, Average Pooling
3. **多层网络**：自动执行多层计算

### 高级项目
1. **DMA控制器**：自动数据传输
2. **INT8量化**：支持量化推理
3. **稀疏矩阵**：跳过零值计算
4. **FPGA实现**：在真实硬件上运行

## 调试技巧

### 1. 波形分析
```bash
# 生成波形
$dumpfile("wave.vcd");
$dumpvars(0, module_name);

# 查看波形
gtkwave wave.vcd
```

**关键信号**：
- 时钟和复位
- 状态机状态
- 数据有效标志
- 握手信号

### 2. 打印调试
```verilog
$display("[%0t] State=%d, Data=%h", $time, state, data);
$monitor("signal=%b", signal);  // 自动监控
```

### 3. 断言
```verilog
assert (condition) else $error("Error message");
```

## 常见问题

### Q1: 为什么使用Q8.8而不是浮点数？
**答**：
- 定点数硬件简单，面积小
- 功耗低
- 对于推理，精度足够
- 浮点数适合训练

### Q2: 脉动阵列和普通并行有什么区别？
**答**：
- 脉动阵列：数据流动，局部通信
- 普通并行：全局互连，复杂布线
- 脉动阵列更适合VLSI实现

### Q3: 如何选择矩阵大小？
**答**：
- 考虑网络层大小
- 平衡面积和性能
- 支持分块计算

### Q4: 为什么需要多个缓存？
**答**：
- 减少内存访问延迟
- 支持数据重用
- 流水线并行

## 参考资料

### 论文
1. "Systolic Arrays" - H.T. Kung (1982)
2. "In-Datacenter Performance Analysis of a Tensor Processing Unit" - Google (2017)
3. "Eyeriss: An Energy-Efficient Reconfigurable Accelerator" - MIT (2016)

### 书籍
1. 《数字集成电路设计》- Rabaey
2. 《计算机体系结构：量化研究方法》- Hennessy & Patterson
3. 《深度学习》- Goodfellow et al.

### 在线资源
- Verilog教程：HDLBits, ASIC World
- AXI协议：ARM AMBA规范
- 神经网络：CS231n课程

## 下一步

完成学习后，你可以：
1. 设计自己的加速器架构
2. 优化现有设计
3. 在FPGA上实现
4. 开发软件驱动
5. 集成到SoC系统

祝学习顺利！
